#!/usr/bin/env node

var request = require("request"),
    htmlparser = require("htmlparser2"),
    fs = require("fs"),
    path = require("path"),
    async = require("async"),
    program = require("commander"),
    gutil = require("gulp-util");

program
  .option("-b --boards [board]", "The board(s) to scrape. Comma-separated lists allowed", "wg")
  .option("-d --directory [dir]", "The directory to store downloaded images", path.join(process.env.HOME, ".4chan"))
  .option("-p --pages [num]", "Number of pages to scrape", 1)
  .parse(process.argv);

function threadname(t) {
  return t.split("/")[t.split("/").length - 1];
}

function printWithBrackets(t, color) {
  return "[ " + gutil.colors[color](
    threadname(t).replace(/-/g, ' ')
  ) + " ]";
}

function scrapePage(board, pagenum, cb) {
  gutil.log("page", printWithBrackets(pagenum.toString(), "yellow"));
  var url = "http://boards.4chan.org/" + board + "/" +
      (pagenum == 1 ? "" : pagenum);
  request.get(url, function (err, res, body) {
    async.eachSeries(getThreads(body), function (t, tcb) {
      gutil.log("thread", printWithBrackets(t, "blue"));
      getThreadImages(board, url + "/" + t, function () {
        tcb();
      });
    }, cb);
  });
}

async.eachSeries(program.boards.split(","), function (board, boardCallback) {
  gutil.log("board", printWithBrackets(board, "yellow"));
  makeDirectories(board, function () {
    var pages = [1,2,3,4,5,6,7,8,9,10];
    async.eachSeries(pages, function (page, pcb) {
      if (page <= program.pages) {
        scrapePage(board, page, pcb);
      } else { pcb() }
    }, boardCallback);
  });
}, function () {
  gutil.log("Done");
});

function makeDirectories(board, cb) {
  fs.mkdir(program.directory, function () {
    fs.mkdir(program.directory + "/" + board, function () {
      cb();
    });
  });
}

function getImage(board, thread, url, cb) {
  var imgname = url.split("/")[url.split("/").length - 1],
      threadDir = program.directory + "/" + board + "/" + thread,
      filename = threadDir + "/" + imgname;

  if (!fs.existsSync(threadDir)) {
    fs.mkdirSync(threadDir);
  };

  if (fs.existsSync(filename)) { return cb() }

  request(url).on("response",  function (res) {
    res.pipe(fs.createWriteStream(filename)).on("finish", cb);
  });
}

function getThreadImages(board, link, cb) {
  request.get(link, function (err, res, body) {
    var links = getThreadImageLinks(body);
    gutil.log("get", gutil.colors.yellow(links.length), "images...");
    async.eachSeries(links, function (i, icb) {
      thread = link.split("/")[link.split("/").length - 1];
      getImage(board, thread, i, icb);
    }, cb);
  });
}

function getThreadImageLinks(content) {
  var imglinks = [];
  var parser = new htmlparser.Parser({
    onopentag: function (name, attribs) {
      if (attribs.class && attribs.href && attribs.class == "fileThumb") {
        imglinks.push("http:" + attribs.href);
      }
    }
  }, {decodeEntities: true});
  parser.write(content);
  parser.end();
  return imglinks;
}

function getThreads(content) {
  var tlink = "";
  var tlinks = [];
  var parser = new htmlparser.Parser({
    onopentag: function (name, attribs) {
      if (attribs.class && attribs.class == "replylink") {
        tlink = attribs.href;
      }
    },
    ontext: function (text) {
      if (tlink && text == "Reply") {
        tlinks.push(tlink);
        tlink = "";
      }
    },
    onclosetag: function (tagname) {

    }
  }, {decodeEntities: true});

  parser.write(content);
  parser.end();
  return tlinks;
}
